{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Clinicians Who Code","text":""},{"location":"#the-opinionated-handbook","title":"The Opinionated Handbook","text":"<p>logo</p> <p>Welcome to this handbook, which has been written to be the guide I wished I'd had when I started coding.</p> <p>If you have enjoyed it and would like to see it improved, extended and updated, then please consider donating and supporting the project.</p>"},{"location":"#complete-beginners-to-tech","title":"Complete beginners to tech","text":"<p>If you are a total beginner in tech, then please feel especially welcome. Everyone can learn more about tech than they already know. Every day you can move a little further along the scale. Beginners may wish to start with content under the Basics tab, to get some definitions and general concepts under their fingers first.</p>"},{"location":"#a-little-tech-experience","title":"A little tech experience","text":"<p>If you already know what clients and are what servers do, and have a clue about cloud, then you could possibly skip Basics and go staright to Getting Started.</p>"},{"location":"Thoughts-from-Mark-Bailey/","title":"Thoughts from Mark Bailey","text":"<p>Test run, see if this works</p> <ul> <li>Section on how to get IT staff to work with clinicians</li> </ul> <p>Software that does not need admin rights to install:</p> <ul> <li>eg Anaconda</li> </ul> <p>Do you want chapter numbers, so people know what order to read things in and where they are when reading?</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#about-this-book","title":"About this Book","text":""},{"location":"about/#about-the-authors","title":"About the Authors","text":""},{"location":"about/#marcus-baw","title":"Marcus Baw","text":"<p>Is a GP</p>"},{"location":"foreword/","title":"Foreword","text":""},{"location":"foreword/#why-is-this-book-needed","title":"Why is this book needed?","text":"<p>This book is the book I wish I'd had available to me back in about 2011 when I started getting back interested in code and clinical informatics.</p> <p>I'd been a 'computery nerd type' at high school and sixth-form college, but I didn't touch computers much from 1995 to about 2002. I got a laptop in 2002 but I only used it for email and web and to write revision notes for the various medical exams I was doing at the time.</p> <p>When I was doing GP training, between 2008 and 2011, I started to get more interested in the computers we were using clinically. In particular I was surprised and disappointed that the amazing computerised GP systems I'd heard so much about when I was in hospital medicine turned out not to really be all that great in reality.</p> <p>Once I started getting more interested in technology, I began to ask around for how you would learn more about the GP systems and how they could be made better. There was virtually nothing. No books, and nothing at all on the internet. Not even any real forums, unless you counted the GP System User groups, which even then were starting to fade into insignificance as the problems GPs faced were less about their own system and more about the interactions of that system with the wider NHS - e-Referrals, e-Prescribing, and more.</p>"},{"location":"foreword/#how-this-book-works","title":"How this book works","text":"<p>Within this book I'm not going to attempt to duplicate any of the great web-based tutorials and learning platforms that are already out there. Instead I'm going to signpost you to the best ones I know of.</p> <p>If you find better ones or problems with the ones I'm recommending then please create an Issue in Github or email me </p>"},{"location":"introduction/","title":"Introduction","text":""},{"location":"introduction/#why-so-opinionated","title":"Why so opinionated?","text":"<p>The web is full of all the information you could possibly want to read about everything I'm talking about in this book. BUt as a begineer there's too much. You can't get a frame of reference to help you decide which way to go. 'Analysis Paralysis' stops you makeing progress. So the whole idea here is I am going to make opinionated recommendations for what to learn and what to spend time on.</p> <p>The purpose of this book is to give you ONE GOOD WAY of getting clinical software written. It's not the 'best' way - just like in clinical practice, often there IS no single 'best' way. There are thousands of ways to do any given task in tech, and you will of course be forgiven if you decide that the way for you is different to my recommendation. But I'm hoping to defeat the options paralysis, and get you started and productive sooner.</p> <p>In many ways one of the inspirations for this book was the Advanced Trauma Life Support course. This course was developed in the 1980s, and revolutionised trauma care - not by being right all the time, but by giving practitioners ONE GOOD WAY of managing trauma.</p>"},{"location":"introduction/#the-atls-story","title":"The ATLS Story","text":"<p>The 'origin story' of ATLS was that an orthopaedic surgeon </p> <ul> <li> <p>ATLS model - ONE GOOD WAY</p> </li> <li> <p>Train the Trainers</p> </li> </ul>"},{"location":"introduction/#what-this-book-is-not","title":"What this book is not","text":"<p>It's not a textbook that will teach you languages, frameworks, etc. I'll link to the places I know of to learn those things I'll link you to the websites for official documentation I want to get on to the health relevant coding as quickly as possible without getting bogged down in re-teaching what is already well-taught all over the web</p>"},{"location":"introduction/#finding-support","title":"Finding support","text":"<p>FCI BCS discourse.digitalhealth.net clinicians who code Stack Overflow documentation sites openhealthhub.org YouTube</p> <p>Bert Weedon</p>"},{"location":"todo/","title":"Todo","text":"<p>what is the cloud using the cloud static sites</p> <p>basics what are servers types of languages compilation workarounds for IT blocking - codeanywhere, github codespaces</p>"},{"location":"todo/#community","title":"community","text":"<p>teach others informal 'training posts'</p>"},{"location":"todo/#getting-work","title":"getting work","text":"<p>apply for grants build what you care about</p>"},{"location":"todo/#talking-about-your-work","title":"talking about your work","text":"<p>Show Your Work screenshotting blogging video recording video editing audio editing image editing excalidraw reveal.js</p>"},{"location":"todo/#royal-colleges-30-best-practice-as-code","title":"royal colleges 3.0 - best practice as code","text":"<p>Browser console debuggering</p>"},{"location":"advanced/legals/","title":"legals","text":"<p>regulation and safety DCB0129/0160 Clinical Safety Officers MHRA CE marking MDR privacy policy GDPR ICO guidance</p>"},{"location":"advanced/nhs-it/","title":"NHS IT","text":""},{"location":"advanced/nhs-it/#anatomy","title":"Anatomy","text":""},{"location":"advanced/nhs-it/#physiology","title":"Physiology","text":""},{"location":"advanced/nhs-it/#pathology","title":"Pathology","text":""},{"location":"basics/conventions-in-this-book/","title":"Conventions used in this book","text":""},{"location":"basics/conventions-in-this-book/#commands-and-code-snippets","title":"Commands and code snippets","text":"<p>Commands that you run by typing into the Command Prompt (Windows), Terminal (MacOS/Linux) or Python console are in monospaced 'typerwriter' font like this</p> <p><code>some code</code></p> <pre><code>&gt;&gt;&gt; print('this is a command')\n</code></pre> <p>Where you need to insert your own details into a command I've used angle brackets and capitals so it looks like <code>&lt;THIS_KIND_OF_THING&gt;</code>:</p> <pre><code>my_secret_api_key = \"&lt;INSERT_YOUR_API_KEY_HERE&gt;\"\n</code></pre> <p>Full-size code snippets have a small 'copy' icon in the top right, which will copy the command to your clipboard for easy pasting.</p>"},{"location":"basics/conventions-in-this-book/#what-is-and-at-the-start-of-a-line-of-code","title":"What is $ and # at the start of a line of code?","text":"<p><code>$</code> is the 'standard-user' command prompt character in Unix/Linux. You type commands after the $, and press Enter to make them run.</p> <p><code>#</code> is the 'super-user' (<code>su</code>) command prompt character in Unix/Linux. It's purely to remind you that you are in super-user mode, and you can cause more damage in this mode! You can get into <code>su</code> mode by typing <code>sudo su</code>, and you will stay in super-user mode until you type <code>exit</code>.</p> <p>My advice is to use standard (<code>$</code>) user mode all the time, and enter super-user only to execute specific commands. You can run a command in <code>su</code> mode by typing <code>sudo</code> and then the command. You will need to enter your admin password.</p> <p>For more information on super-user, see Managing Servers</p>"},{"location":"basics/conventions-in-this-book/#tips","title":"Tips","text":"<p>Marcus's Random Tips</p> <p>Scattered through the book, formatted in these 'tip' boxes, I've included some tips and advice which I've either learned from opther places during my time in tech, or which I've concluded myself. I've tried to make them interesting and actionable. (I'm sure you'll tell me if they aren't)</p>"},{"location":"basics/focus/","title":"Obtaining Focus","text":"<p>One of ths things I have found most difficult about learning to code and writing code is Obtaining The Focus. Because of the amount of intangible bits of information you need to hold in your brain all the time when you ar coding on anything even moderately challenging, it can take a good 20-30 minutes to really get 'into' the coding. If you're interrupted - by, say, having to answer the door for a delivery - you lose that focus, and you have to spend time getting back into 'the zone'.</p> <p>Sometimes whole days of poor productivity result from just being unable to get enough focus to get the job done. Occasionally you have to write off a whole day because of repeated distractions. The distractions don't always come from outside or from other people.</p> <p>You can't insulate yourself from all distractions, but you can do some things to try to reduce them.</p> <ul> <li> <p>Find a place to code with fewer distractions around. It needn't be silent. But if you can see a load of jobs to do, or are being called by name all the time, you'll struggle to find focus.</p> </li> <li> <p>Make yourself comfortable. Aim for a good posture, yes of course, but mostly aim to be comfortable. I sometimes code laid out on the sofa.</p> </li> <li> <p>Headphones can help. A developer friend of mine once said that he wears headphones 100% of the time at work - even if he's not actually listening to music! - he felt it definitely stops people from interrupting your focus unless they really needed to. A decent pair of headphones will isolate you from outside noise, and also give you immense listening pleasure!</p> </li> <li> <p>I've found that listening to instrumental music can let you fall into focus easier. Classical music or any other instrumental music works, although I've particularly found that music with a steady, semi-hypnotic beat works really well. I've become quite a fan of the Carbon Based Lifeforms and also a genre called Psybient/Psychill. There are some good Concentration/Coding playlists on Spotify and YouTube. 'Lo-fi beats' also seem to help with focus. (I'm way too old to be making any kind of music recommendations to anyone, but if I was going to, this is what I'd say) Music is very individual though. Listen to what works for you. Instrumental Metal? Bardcore?</p> </li> <li> <p>If you have a really excitingly productive day, it's often followed by a day which is disappointingly scatterbrained and aimless. And vice versa. So don't worry about these 'off' days whatsoever, the next day will likely be back to normal. Roll with the off days. If your brain won't write code on those days, then let it do whatever you can get it to do. Maybe rest? Come back to the code another day.</p> </li> </ul> <p>Tip - Abilene, TX and the ZOUD</p> <p>Know where Abilene, TX is and know why you do not want to go there. Recognise when other people are going there. Help them avoid it, if you can. Know where the Zone Of Uncomfortable Debate is, and go there as often as is necessary.</p>"},{"location":"basics/glossary/","title":"Glossary terms","text":"<p>RFC</p>"},{"location":"basics/mantras/","title":"Mantras","text":"<p>I've collected together some thoughts for when you need them</p> <p>Tip</p> <p>Anyone who is suitably motivated can learn to code. Anyone.</p> <p>Tip</p> <p>You can get yourself un-stuck.</p> <p>Tip</p> <p>Never give up. By all means put the work away till tomorrow, till next week, till next year. But come back to it with new eyes and you'll see where you were going wrong.</p> <p>Tip</p> <p>Listen to, and act on, EVERY LITTLE THING that Joe McDonald says. Always.</p> <p>Tip</p> <p>Know what a Million Pound Chair is actually worth.</p>"},{"location":"basics/open-source/","title":"What is Open Source and why should I care?","text":""},{"location":"basics/support/","title":"Sources of Help and Support","text":"<p>Where you get help from often depends on the question you're asking</p> <ul> <li>Copy and paste the error message into Google</li> <li>stackoverflow</li> <li>Digital Health Networks, especially CWC section</li> <li>Twitter</li> <li>Online forums for the technology in question</li> </ul> <p>Note that NHS IT and services such as the Spine sadly don't (at the time of writing) have any open forums to help you integrate with them. This is a source of deep frustration for me, because providing proper online support channels is really such a basic part of providing a service, and is cheap, easy, and completely expected in the 'real tech world'.</p> <ul> <li>OpenHealthHub.org</li> </ul> <p>Other support channels Interopen Ryver FHIR zulip openEHR forums FCI RCGP HIG Telegram Slack Gitter Matrix/Riot</p>"},{"location":"basics/usability/","title":"Usability and User Experience","text":"<p>I will put money down that at least part of the reason that you as a clinician are getting involved in code and programming is that you've been a victim of the poor usability of the systems you've used, both clinical and non-clinical, in your everyday work.</p> <p>The Psychology of Everyday Things</p>"},{"location":"getting-started/learning-django/","title":"Learning Django","text":"<p>Django is an opinionated web framework for Python, which aims to reduce the amount of work required to build a web application.</p> <p>It prefers 'Convention' over 'Configuration', meaning that, much like this book, it reduces the problem space and prevents 'analysis paralysis'. It also encourages, through convention, the use of good practices.</p> <p>I like this way of standardising things. You make it so much easier to do things properly, that nobody can be bothered to do it wrong because it's more work! It's something that I will be advocating later in the book when we get to creating clinical standards in software.</p>"},{"location":"getting-started/learning-django/#what-django-helps-you-with","title":"What Django helps you with","text":"<ul> <li>Structuring your project in a logical way so that other developers can easily find their way around.</li> <li>Definining a data model for the information your application will store.</li> <li>Connecting the data in Python to a database or other 'persistence' type so that it can be saved for later.</li> <li>Creating the HTML that the user will see in the web browser. It simplifies the task of 'mail merging' the fields from your database into the HTML page.</li> <li>Security eg HTTPS, backend admin pages and translations/internationalisation (also called i18n' for short)</li> <li>Accessibility and adherence to good practice.</li> <li>Sharing your application as a 'module' that could be used in other applications.</li> </ul>"},{"location":"getting-started/learning-django/#how-to-learn-django","title":"How to learn Django","text":"<p>You should have a reasonable understanding of the Python language before starting to learn Django. If you have completed the free Python2 course on CodeCademy, as recommended in the Learn Python section, then you probably know enough.</p> <p>Django uses Python syntax, but adds in quite a lot of new concepts on top. It can take a bit of time to feel familiar with what is happening.</p> <p>As with the Python section, I'm not going to duplicate in this book material that is better explained elsewhere, so this is the point I hand you off to free places on the web where you can learn Django</p> <p>https://www.djangoproject.com/ has a good landing page with some more of the benefits of Django listed, which are worth reading. From there, you can follow the instructions to install Django, and then I'd recommend to follow the Django Tutorial.</p> <p>https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django is another good tutorial for Django.</p>"},{"location":"getting-started/learning-python/","title":"Learning Python","text":"<p>There are a plethora of ways to learn Python, both online and offline. Here are a few that I would recommend, but what's available is changing all the time - let me know if you hit problems with something I'm recommending here, or if you know of better resources.</p> <p>Improve this book!</p> <p>If you have found an error, or have something to contribute that would improve the book, you can email me,  create a GitHub Issue, or even submit a Pull Request</p>"},{"location":"getting-started/learning-python/#codecademy","title":"CodeCademy","text":"<p>This is where I learned Python originally, and still a great course. You learn step-by-step and everything is in a browser so you don't need to be able to install things on the local machine to be able to learn. This is great when you're in clinical work but have a short break and want to do some learning. https://www.codecademy.com/learn/learn-python</p> <p>The Python 2 course is free, and really there is very little difference between Python 2 and 3 at this level, so I'd say you're fine learning Python 2 here.</p>"},{"location":"getting-started/learning-python/#learnpythonorg","title":"learnpython.org","text":"<p>Another great, web based site which steps you through the main things you need to learn to be able to code in Python. https://www.learnpython.org/</p>"},{"location":"getting-started/learning-python/#python-koans","title":"Python Koans","text":"<p>This project was ported over from Ruby (another language which is quite similar to Python) - and originally I did these Koans in Ruby. I'm not sure if I actually completed them all, though. The nice thing about them is that they run in your terminal, offline, so if you don't have an internet connection you can still do them. I remember doing these on the train to London from Yorkshire, when connections where patchy. https://github.com/gregmalcolm/python_koans</p>"},{"location":"getting-started/learning-python/#my-python-tips","title":"My Python tips","text":""},{"location":"getting-started/learning-python/#using-pyenv-for-virtualenvs-and-python-version-management","title":"Using <code>pyenv</code> for 'virtualenvs' and Python version management","text":"<p>Once you are writing Python programs on your local machine regularly, and especially if you are working with other people's code or on shared projects, you'll inevitably hit a situation where you need to have multiple different versions of a Python package installed on your computer, or different versions of Python itself.</p>"},{"location":"getting-started/learning-python/#use-pyenv","title":"Use <code>pyenv</code>","text":"<p>Although Python has a number of tools available to help manage this problem, I found <code>pyenv</code> to be the easiest to use. It allows you to manage Python versions and your collections of libraries on a 'per-project' basis very easily.</p> <p>Tip</p> <p>At first I remember thinking it was a lot of extra hassle to bother with <code>pyenv</code>, especially when you are just starting, but it really does pay dividends later when you find it's really easy to have numerous different python versions and library collections on your machine. You can also solve this problem with Docker containers, but that is a lot more to learn at this stage and I'd recommend to leave those till later.</p> <p>You can find out how to install and use <code>pyenv</code> here: https://github.com/pyenv/pyenv#readme (it's a GitHub README.md, which is often used for this kind of technical documentation).</p> <p>There's also a quite helpful 'Intro to pyenv' tutorial I found here https://realpython.com/intro-to-pyenv/</p>"},{"location":"getting-started/learning-python/#my-pyenv-tips","title":"My <code>pyenv</code> Tips","text":"<p>use <code>pyenv local &lt;VIRTUALENV_NAME&gt;</code> to create a <code>.python-version</code> file in the root of projects. That way, when you navigate to the project root, <code>pyenv</code> will automatically select your</p>"},{"location":"getting-started/learning-python/#i-want-moar-python-learning","title":"I want MOAR Python learning!","text":"<p>FreeCodeCamp's Learn Scientific Computing with Python track is a big course, but wow there's a lot in there. If you do that course you know more Python than I do, for sure. https://www.freecodecamp.org/learn/scientific-computing-with-python/</p>"},{"location":"getting-started/shell/","title":"What the hell is a 'shell'?","text":"<p>shell bash zsh command prompt WSL advantages of shells ZSH &amp; oh-my-zsh</p>"},{"location":"getting-started/text-editor/","title":"Which text editor?","text":"<p>Another source of needless options paralysis, is \"Which text editor shall I use for my code?\".</p> <p>There are many available (hundreds, at least), and they cater for all sorts of needs </p>"},{"location":"getting-started/text-editor/#use-vscode","title":"Use VSCode","text":"<p>Microsoft VSCode is a really nice, stable and feature-packed editor which has come from 'nowhere' to being one of the most commonly used text editors,in just a couple of years. It is simple enough to be 'simple' for the people that like simple. But it can be extended using extenstions to have lots of helpful features, which make it more like an 'Integrated Development Environment'. It has lots of extensions which make it easy to handle Git and GitHub repositories, many different coding practices and styles, and even things like Docker containers.</p> <p>It's free and open source. I strongly recommend it. In the end you may settle on something different, but VSCode will get you through anything in this book.</p> <p>Download here https://code.visualstudio.com/download</p>"},{"location":"getting-started/text-editor/#suggested-vscode-plugins","title":"Suggested VSCode plugins","text":"<p>You don't need to install all of these at the start, perhaps install the first few and then install the others as and when you start to be using that particular tool or technology.</p> <ul> <li>Python</li> <li>Git </li> <li>Github</li> <li>Prettier</li> <li>LiveShare</li> <li>Docker</li> <li>Markdown All In One</li> <li>Markdown Preview GitHub Styling</li> <li>YAML</li> </ul> <p>You can experiment with many different visual themes for the overall VSCode UI and the syntax highlight colours used. I use Solarized Dark pretty much everywhere I can. Search the Extensions for <code>theme</code>.</p>"},{"location":"getting-started/text-editor/#learn-nano-for-when-there-is-no-gui","title":"Learn <code>nano</code> for when there is no GUI","text":"<p>Sometimes you will need to edit a configuration file on a remote server using a text-only login such as SSH. You will not be able to use a sophisticated text editor because there is only a text interface. There is almost always a text-based editor available, except in the most minimal of installations. I tend to use the <code>nano</code> text editor (even though many people are derisory about it). It works for me. It doesn't really matter, you are not going to be using it for writing acres of code, just small edits to config files.</p> <p>To edit a file</p> <pre><code>nano &lt;FILENAME&gt;\n</code></pre> <ul> <li> <p>If the file doesn't exist it will be created</p> </li> <li> <p>Navigate up and down using the arrow keys. Normal typing works as you would expect, and you can use Del to delete, again no surprises here.</p> </li> <li> <p>To delete a whole line, you can use Ctrl+K, this is a handy trick</p> </li> <li> <p>To save, press Ctrl+O</p> </li> <li> <p>To exit, press Ctrl+X</p> </li> <li> <p>If you can't make it save, this could be because the file is protected and you need <code>sudo</code> permissions. Running <code>nano</code> like this will usually fix it.</p> </li> </ul> <pre><code>sudo nano &lt;FILENAME&gt;\n</code></pre> <p>see chapters on server management for more information on Linux and <code>sudo</code></p> <p>Tip - You don't need to invent anything - transplant ideas from elsewhere... in both directions!</p> <p>Look at how the 'real' industry (ie outside of healthcare) solves generic problems, and bring those solutions into healthcare technology. That's all I'm doing most of the time. Examples are things like open 'RFC' standards and version control, automation, and open source.</p> <p>However, also note the places where healthcare culture has got it right, and the tech industry should be learning from us! An example of this is the 'precautionary principle' - proving something is safe before using it widely. This is how we do Evidence Based Medicine, and sadly is not widely practiced in the majority of the tech industry, where 'move fast and break stuff' is a sad adage (attr: Facebook)</p>"},{"location":"getting-started/web-frameworks/","title":"Web Frameworks","text":""},{"location":"getting-started/web-frameworks/#what-is-a-web-framework","title":"What is a Web Framework?","text":""},{"location":"getting-started/web-frameworks/#django","title":"Django","text":""},{"location":"getting-started/web-frameworks/#flask","title":"Flask","text":""},{"location":"getting-started/web-frameworks/#what-about-frontend-frameworks","title":"What about frontend frameworks?","text":"<p>React Recognise they are building 2 apps For any non-trivial application you need a server-side framework too Auth can be a headache Websockets and raw HTML are starting to solve this problem server-side Dev time is 10000000 time more expensive than CPU cycles, whether they're yours on servers or the consumer's in their browser</p>"},{"location":"getting-started/web-frameworks/#mobile-apps","title":"Mobile apps","text":"<p>React Native</p> <p>Mantra - Clinicians are smart and can learn code if they want</p> <p>A clinician of any kind, any level, and any background, is by definition intelligent and motivated and capable. That's you. You can learn to code just as you learned all the other things you needed to learn to develop your professional skills.</p>"},{"location":"getting-started/what-language/","title":"What Language Should I Learn?","text":"<p>Answer: Learn Python</p> <p>One of the first problems that you hit when learning to code is the question of which language to learn.</p> <p>I'm going to end that 'options paralysis' for you right now by advising, no - asking - you to learn Python. Why 'asking'? - because I believe that as Clinicians Who Code we have to band together and collectivise around a language that we can all use, and more importantly, we need to build tools that solve problems and then share those tools widely and openly in standard ways like using the PyPi, the Python Package Index.</p> <p>If that's enough for you, then you can skip right on to learning how to Python! You will learn other tools later. But start with Python.</p> <p>But if you need some more in-depth reasoning for why to learn Python, then read on.</p>"},{"location":"getting-started/what-language/#why-it-matters-to-get-on-and-learn-python-now-and-then-learn-other-stuff-later","title":"Why it matters to get on and learn Python now, and then learn other stuff later","text":"<p>When I started wanting to code, I asked some friends what would be a good language to learn. I got a variety of answers, but it took me some time to make decent conclusions about whether they were the right things to learn. In short, I wasted quite a bit of time learning languages that were either terrible (Java) or the wrong thing (C) for my needs. So you can skip all that and cut to the chase. Learn Python.</p> <p>One person said \"Learn Java because it's 'Enterprise-y' and healthcare applications sound like they are Enterprise-y\". Another advised me to start with the basics and learn C or C++ so that I could write super-fast programs. I actually bought books on both of these and really didn't hit it off with either. I then tried Python and subsequently Ruby, and I immediately found them more friendly and straightforward. I've also played around with newer, languages like Elixir and Golang, as well as PHP, Javascript, and Rust. But if you want my advice, Learn Python.</p> <p>This is a roundabout way of saying that none of the languages you could choose are 'right' or 'wrong'. Many of the available alternative languages are absolutely excellent languages. That's in fact what makes it so hard to decide. And you can easily plough a lot of your time into the learning curves of a variety of different languages, tyrying to decide what is right for you, when you could be making useful things for healthcare if you just Learn Python.</p> <p>I also believe there is a critical mass effect thing here as well. By concentrating the resources of the Clinicians Who Code community around Python, we can make more progress than if we spread ourselves across numerous languages, tools and frameworks.</p>"},{"location":"getting-started/what-language/#why-the-choice-of-language-matters-less-than-you-think-once-you-get-going","title":"Why the choice of language matters less than you think, once you get going","text":"<p>If we are designing our clinical digital tools right, then actually we should be building them so that the inputs and outputs are language agnostic, in other words, that the language used to process the data doesn't matter to the user. So, since the choice of language isn't all that important, it's even more reason not to faff about deciding, and just get on and Learn Python.</p> <p>Example</p> <p>If I build a clinical calculator program, I could make it so that the data going in is in a language-agnostic format such as JSON, and the data coming out is also language-agnostic too:</p> <pre><code># the input data is in JSON in the { } bit\n# we pass it to our program 'creatinine-ckd-epi' using the 'pipe': |\n\n$ echo \"{'sex': 'male', 'serum_creatinine': 50, 'age': 80, 'race': 'non-black'}\" | ./creatinine-ckd-epi\n\n# result - the output data is also in JSON format, in the { } bit\n{'value': 97, 'units': 'ml/min/1.73m2'}\n</code></pre> <p>This is an over-simplifed example, but it is here just to explain that we can make our programs in such a way that it doesn't matter what language we wrote them in. We can this and other methods like REST APIs to wrap our code so that it can be called from programs written in any language.</p>"},{"location":"getting-started/what-language/#why-choosing-a-single-language-across-a-community-does-matter","title":"Why choosing a single language across a community does matter","text":"<p>If every clinician set off on their own independent learning journey and chose a language almost at random, then sure, we'd have a lot of Clinicians Who Code, but the opportunities for collaboration are greatly reduced. If we choose to stick together then we can all help out on each others' code.</p> <p>We can also share libraries of code, all in Python, that help each other to do things that are currently rather hard to do. Healthcare tech is a long way behind the rest of the tech world in terms of the reusable, shared libraries of code that make things easier in our 'domain of expertise'. There are huge numbers of good quality libraries available for statistics, cryptography, and so much else, but comparatively little that would help us in medicine.</p> <p>Fictional Libraries...</p> <p>As a quick example, wouldn't it be great if there were already libraries to calculate some of the parameters we use in everyday care? It would! -  unfortunately they just don't exist yet. I want to be able to do something like:</p> <pre><code>$ python                 # start the python interpreter\n&gt;&gt;&gt; import snomedct      # import some fictional libraries\n&gt;&gt;&gt; import ckdepi\n\n# calculate an eGFR from Serum Creatinine using a standard algorithm\n&gt;&gt;&gt; egfr = ckdepi.Creatinine(sex: 'male', serum_creatinine: 50, age: 80, race: 'non-black'); print(egfr)\n{'value': 97, 'units': 'ml/min/1.73m2'}\n\n# work out the CKD stage from the eGFR\n&gt;&gt;&gt; ckd_stage = ckdepi.Staging(creatinine_clearance['value']); print(ckd_stage)\n{'value': 'CKD stage I'}\n\n# Get the appropriate SNOMED-CT term\n&gt;&gt;&gt; sct = snomedct.search(ckd_stage['value']); print(sct)\n{'sct_id': '431855005', 'text': 'Chronic kidney disease stage 1 (disorder)'}\n\n# Print a report!\n&gt;&gt;&gt; print(f\"Kidney Report: \\nStatus: {sct['text']} \\nStore as SNOMED-CT: {sct['sct_id']}\\neGFR value: {egfr['value']} {egfr['units']}\")\nKidney Report:\nStatus: Chronic kidney disease stage 1 (disorder) \nStore as SNOMED-CT: 431855005\neGFR value: 97 ml/min/1.73m2\n</code></pre> <p>If dozens or hundreds of Clinicians Who Code built just one library each, that solves a personal programming need, and publish these libraries in open source so we can all review and improve them, we would soon build an international, community-curated collection of safe, independently-clinically-validated libraries that would make the above example possible, turning it from a quite hard problem to solve (which it is currently, it's several day's work at least) to something you could happily do in 5 minutes.</p> <p>That's what I mean by building a critical mass behind Python as a clinical programming language.</p>"},{"location":"getting-started/what-language/#you-dont-need-to-optimise-for-scale-or-speed-at-the-start","title":"You don't need to optimise for scale or speed at the start","text":"<p>Programmer brains by far the most expensive commodity in the technology world. Doubly so for the Clinician Who Codes, where you are bringing domain expertise to every line of code. CPU cycles are cheap and are always getting cheaper.</p> <p>The most common reason for an idea to fail is not that it was too slow to scale. It's actually that it never got built in the first place. That's where most ideas die. In development.</p> <p>Ideas are worthless; execution on ideas is everything.</p> <p>So, choose a language that lets you build things quickly, right now. Efficient syntax, easy to learn, developer friendly, and has rich libraries. A big developer community so you can ask questions on StackOverflow and get sensible answers. A mature language so you know it will be around for a while. Good, enterprise-grade web frameworks. Y'know. Python, basically.</p> <p>Another reason not to worry preematurely about scale is that the scale of the NHS is tiny in comparison to the 'real tech world' of WhatsApp and Facebook. Even if you had every NHS staff member simultaneously logged into your app, this is about 1.5 million people. WhatsApp can get 2 million concurrent connections out of one server, but by the time you need to optimise your app for this kind of performance you'll have a large team to help you!</p> <p>Scaling too early introduces a lot of complexity to your setup and deployment. Build so that future scaling is possible (with cloud deployments this is very easy anyway) but don't build using a fashionable new language for speed and performance if it is going to make initial development much slower.</p> <p>Fix</p> <p>I remember hearing on a podcast about coding that you should just tweak just one little thing in your programming workflow every day.</p> <p>This could be by simply adding a useful plugin to your editor, a helpful accessory to your desktop, finding a physically better place to work. But each thing you fix makes you more efficient and better focused.</p> <p>See Accessories for some of my tips in this area.</p>"},{"location":"getting-started/why-python/","title":"Why Python?","text":"<p>Why is Python a good language to learn first?</p>"},{"location":"getting-started/why-python/#ease-of-learning-and-use","title":"Ease of learning and use","text":"<p>Python is taught in schools across the world, to children from around the age of 8 upwards. It's readable enough to make sense even if you don't actually code yet.</p> <p>As an interpreted (as opposed to compiled) language, the 'type-it-try-it-fix-it-try-it' cycle is that much shorter.</p> <p>It's supported in 'serverless' deployment features by basically all the major platforms such as Heroku, Microsoft Azure, Amazon Web Services, so it's quite easy to deploy experiments and demos.</p> <p>You can use it in Jupyter Notebook form, which is great for data science experiments, live coding demos, and sharing step-by-step code examples.</p>"},{"location":"getting-started/why-python/#pythons-the-de-facto-science-language","title":"Python's the de-facto science language","text":"<p>Python is widely used for all the 'standard' and common things that we use code for - scripting, small simple programs, desktop programs with a graphical user interface, and web programming.</p> <p>In addition, it's been adopted as the primary language of the scientific community, for uses ranging from astrophysics to bioinformatics. Python's scientific and statistical libraries are mature and well supported.</p> <p>Python is also used in a lot of 'cutting edge' things such as machine learning, natural language processing, computer vision and image recognition.</p> <p>Data science also uses a lot of Python although that community is also strongly invested in the R language, which is specifically aimed at statistical analysis and data visualisation.</p> <p>Medicine is (primarily) a scientific discipline. Yeah, it's an art too, but for the computing side of things, science is the way to go. Let's give scientific tools to the humans who practice the art of medicine. I love the phrase 'Machine Assisted Human'. It's something I came up with when trying to describe what we were doing with the UI of a new GP system. We're not trying to replace the human, we're trying to give the human practitioner 'super-powers'. That's the future of medicine.</p>"},{"location":"getting-started/why-python/#one-language-critical-mass","title":"One language, Critical mass","text":"<p>So, to make progress faster, we need to group together and 'centralise' our efforts around a single language, or at most a small cluster of languages and frameworks, building and sharing tools that make us all more efficient and productive.</p> <p>Although I am confident that any clinician of any kind, from any background, can learn to code, the fact remains that at present there aren't all that many of us Clinicians Who Code yet. One day, all clinicians will be able to code. It probably isn't that far away - 10-20 years? So let's start building now the tools that those clinicians will need.</p> <p>We need to collectivise our efforts behind a single language so that we focus on developing the ecosystem of tools and libraries of code that are needed. If we're spread across many languages then we simply won't hit a 'critical mass', or at least it could take longer to hit it.</p>"},{"location":"getting-started/why-python/#pythons-ecosystem","title":"Python's ecosystem","text":"<p>Python has a huge ecosystem of mature, reliable tools in its libraries. Libraries are called different things in different languages, but they all do the same essential function - they are reusable units of code that you can use in your programs to make it easier to make progress faster.</p> <p>Python has a great Web Framework (a library which makes it easier to build web applications) called Django, which is used at full production scale for a number of major websites including Instagram, Pinterest and Udemy. The daily traffic going through these sites is probably a million times the entire NHS data throughput. Django will cope fine. If you get to the point where parts of your application need to be replatformed to a faster-performing language because of the sheer volume of traffic, then you have a Champagne Problem. Until then, you'll be fine with these tools. See Solving Imaginary Scaling Issues At Scale</p>"},{"location":"getting-started/why-python/#community","title":"Community","text":"<p>A word you will read a fair bit in this book is 'Community'. You are part of building a community of Clinicians Who Code, but also, we're part of a larger community - of all coders, and also - a community of all clinicians. We're a very special part of the Venn diagram.</p> <p>I've built up several communities within health tech - the main ones being  and , and there are a few others. Community is hugely important. It gives the members a place to talk, to learn, understand, discuss, and disagree. We can use a community to explore the Zone Of Uncomfortable Debate. <p>Communities make us more productive, simply because we can learn from each other. It's a right that you have, in any good community, to ask for help, and you should get it. Similarly, as you start to accrue knowledge in the community, it's a responsibility of yours now to share your knowledge with the other members. Be nice. You were a beginner too, once.</p>"},{"location":"getting-started/why-python/#miscellaneous-other-reasons","title":"Miscellaneous other reasons...","text":"<ul> <li> <p>Want to use a C program in Python? - no problem, it has several easy ways to wrap a C library in a Python wrapper.</p> </li> <li> <p>Want to use Python for Internet Of Things development? - you can use Python for that: https://micropython.org/</p> </li> </ul>"},{"location":"getting-started/why-python/#things-i-dont-love-so-much-about-python","title":"Things I don't love so much about Python","text":"<p>(But still learn Python please...)</p>"},{"location":"getting-started/why-python/#pydantry","title":"Pydantry","text":"<p>Python likes things to be done the right way, and the design of the language is intended to give you 'one good way' of doing things (just like the ATLS course). Occasionally this can make it seem like Python is being annoyingly pedantic, as seen in this commonly encountered example:</p> <p>Pydantry in motion</p> <pre><code>\u2570\u2500$ python\nPython 3.8.0 (default, Aug 23 2020, 17:45:09)\n[GCC 9.3.0] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; exit\nUse exit() or Ctrl-D (i.e. EOF) to exit\n&gt;&gt;&gt;\n</code></pre> <p>I typed <code>exit</code> - Python clearly understood what I intended to do, because it gave me advice on how to successfully exit. But it wants me to do it the right way, so it's going to deliberately not exit and wait superciliously for me to do it properly. </p>"},{"location":"getting-started/why-python/#its-not-ruby","title":"It's not Ruby","text":"<p>This is a minor complaint, since Ruby is fairly close in style to Python. But in Python, things like method chaining look ugly:</p> <pre><code>len(\"My_Text\".upper().split('_')[1].encode())\n</code></pre> <p>Notice all the empty parentheses <code>()</code>? And the fact that sometimes you use dot notation to chain the operations, and other times you enclose the expression with a function call <code>len()</code>. There's probably some logic in there somewhere, but certainly no elegance.</p> <p>Same thing in Ruby:</p> <pre><code>\"My_Text\".upcase.split('_')[1].encode.length\n</code></pre> <p>Just cleaner and neater. Elegant and well thought through.</p> <p>But despite this, I've had to get over myself, suck it up, and stick to Python for any projects that other people might need to get involved in. So should you.</p> <p>Late night problem solving</p> <p>Never underestimate the problem solving potential of a decent night's sleep. If you really can't make it work, put it away for the night. Your brain is still going to be working on it. And you get to sleep through it all. Over night, quite often, the solution will just be obvious in the morning. And if it's still not obvious - at least you're now attacking it with a well-rested brain.</p>"},{"location":"getting-started/workplace/","title":"Where and how to work","text":"<p>postiure sytanding desks changing posture throughout the day external monitors and keyboards on laptops</p>"},{"location":"intermediate/accessories/","title":"Productivity tools","text":""},{"location":"intermediate/accessories/#clipboard-manager-copyq","title":"Clipboard manager - CopyQ","text":""},{"location":"intermediate/accessories/#launcher","title":"Launcher","text":"<p>Rubber duck debugging</p> <p>Tell someone else, in logical steps, about the maddening, infuriating, completely impossible bug or problem you have. The act of writing the problem down - be it in a StackOverflow post, an email, or a WhatsApp message - quite often triggers an \"Ohhhhhhh\" (realisation) moment, and you've solved it yourself by explaining it to your own brain. This so common it even has a name - the Rubber Duck Debugging technique.</p> <p>I've done this so often. Sometimes I still send the email to thank the person for having solved it for me, even though they never knew they had.</p>"},{"location":"intermediate/authentication/","title":"Authentication","text":""},{"location":"intermediate/authentication/#introduction","title":"Introduction","text":"<p>Authentication can be a feat as simple or as complex as you want it to be. In-built authentication can be the easiest (so long as you accept that you store user's passwords, albeit hashed), and there are some systems where this is ideal -- think small single-user applications. Similarly, there are some applications where you'll want to use another authentication system. If you're developing a system for an organisation, it makes sense to try and use what they use - why should I have two different accounts to login to my work computer and my other work tools?</p> <p>In these contexts, it makes sense to use the same authentication system as the organisation. This is where LDAP comes in.</p>"},{"location":"intermediate/authentication/#ldap","title":"LDAP","text":"<p>Putting it simply, LDAP (lightweight directory access protocol) is a protocol that allows us to query directory services. The most common directory service in large organisations is Active Directory (AD), which is what Microsoft uses to manage users, devices, access control, etc. When you log into your work computer, you're (most likely) authenticating against AD. We can harness this to make user experience much simpler for our users, and safer for us as developers (we don't have to store passwords!).</p>"},{"location":"intermediate/authentication/#pros","title":"Pros","text":"<ul> <li>Users use the same user account they use to log in, so one less password to remember</li> <li>It's the same account, so password changes are reflected immediately</li> <li>You can access other information about the user, such as their email address, etc</li> <li>You can view the user's group memberships, which can be used for access control</li> <li>The application doesn't need to store passwords (safer + less complexity)</li> </ul>"},{"location":"intermediate/authentication/#cons","title":"Cons","text":"<ul> <li>Requires the application to be on the same internal network as the directory server</li> <li>Some features may require engagement from the organisation's IT department</li> </ul>"},{"location":"intermediate/authentication/#it-engagement","title":"IT engagement","text":"<p>Some desirable features of LDAP might not be allowed by your local IT teams. This can include access to view group memberships, or to view other attributes of the user. From a security perspective, this can be a reasonable measure but you may be allowed a specific user account (service account) that has these permissions.</p>"},{"location":"intermediate/authentication/#saml","title":"SAML","text":"<p>SAML (Security Assertion Markup Language) is a protocol for authentication and authorisation. It's more complex than LDAP, but it can also be more secure. SAML follows an OAuth-style authentication flow where the user is redirected to the identity provider (IdP) to authenticate, and then redirected back to the application with a token. This token can then be used to authenticate the user against the IdP, and to access other information about the user. This also means that multi-factor authentication can be handled by the IdP, which additionally means the application is simpler for not having to handle this. It also means that were an organisation requires MFA, the application doesn't need to be aware of or handle this.</p>"},{"location":"intermediate/authentication/#pros_1","title":"Pros","text":"<ul> <li>The application server doesn't need to be on the same network as the directory server</li> <li>Can be used to authenticate against multiple directory servers</li> <li>Follows trust policies around multi-factor authentication</li> <li>All authentication complexity is handled by the IdP</li> </ul>"},{"location":"intermediate/authentication/#cons_1","title":"Cons","text":"<ul> <li>Requires more configuration than LDAP</li> <li>Can be much more complex than LDAP</li> <li>Requires engagement from the organisation's IT department from the get-go</li> </ul> <p>Context is everything</p> <p>Keep it simple. If you don't need to implement an advanced authentication mechanism, don't! Keep it simple now, and add complexity later if you need it. Remember, it's easier to add complexity than it is to remove it. Keeping it simple also means there's less to go wrong!</p>"},{"location":"intermediate/documentation/","title":"Documentation","text":"<p>markdown github README.md material for mkdocs</p>"},{"location":"intermediate/git/","title":"Git","text":""},{"location":"intermediate/git/#pull-requests","title":"Pull Requests","text":"<p>Mantra - Own the pain of learning</p> <p>If you find something hard, that's exactly when you're learning.</p> <p>Take a moment to recognise that feeling of difficulty, maybe even frustration. Own it.</p> <p>Acknowledge that it is hard because you're learning, not because of any other imagined reason such as that you are inadequate or don't have the right sort of brain.</p> <p>Lean into that difficulty, apply your capability, and keep at it. Success will come, but not immediately.</p>"},{"location":"intermediate/govuk-notify/","title":"GOV.UK Notify","text":""},{"location":"intermediate/govuk-notify/#introduction","title":"Introduction","text":"<p>I adore Notify. It's (within reason) free, and really simple to use.</p>"},{"location":"intermediate/managing-servers/","title":"Managing servers","text":"<p>linux ubuntu ssh ssh keys</p>"}]}